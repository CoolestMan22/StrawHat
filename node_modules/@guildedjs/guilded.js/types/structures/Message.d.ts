import Collection from '@discordjs/collection';
import { parsedMessage } from '@guildedjs/common';
import type { APIMessage, APIMessageReaction } from '@guildedjs/guilded-api-typings';
import type { PartialMessageData, UpgradedMessageData } from '../typings';
import { Base } from './Base';
import { DMChannel, PartialChannel, TeamChannel } from './Channel';
import type { Client } from './Client';
import { Member } from './Member';
import { Role } from './Role';
import type { Team } from './Team';
import { User } from './User';
/**
 * Object representing a message sent on the Guilded API.
 * This class is used over a partial message when we have full data.
 */
export declare class Message extends Base<APIMessage> {
    private _channel;
    /**
     * The channelID in which this message was sent. Will always be present, even if the channel isn't cached
     * @readonly
     */
    readonly channelID: string;
    /**
     * The plain text content that this message has
     */
    content: string;
    /**
     * Whether this message has been deleted or not.
     */
    deleted: boolean;
    /**
     * The parsed but unjoined content that this message has
     */
    parsedContent: parsedMessage;
    /**
     * Author of the message
     */
    readonly authorID: string;
    /**
     * The ID of the team this message was sent in
     */
    readonly teamID: string | null;
    /**
     * Reactions on this message
     */
    reactions: Collection<string, MessageReaction>;
    /**
     * Mentions contained in this message
     */
    mentions: {
        channels: Collection<string, PartialChannel>;
        members: Collection<string, Member>;
        raw: {
            channels: Set<string>;
            roles: Set<string>;
            users: Set<string>;
        };
        roles: Collection<string, Role>;
        users: Collection<string, User>;
    };
    /**
     * A boolean indicating that this message is NOT partial
     * @readonly
     * @defaultValue false
     */
    readonly partial = false;
    private _team;
    constructor(client: Client, data: UpgradedMessageData, _channel: DMChannel | TeamChannel | PartialChannel | null);
    /**
     * Update the data in this structure
     * @internal
     */
    patch(data: APIMessage | Partial<APIMessage>): this;
    /**
     * Retrieve the team object that channel this message belongs to belongs to.
     */
    get team(): Team | null;
    /**
     * Retrieve the channel object that this message belongs to.
     */
    get channel(): DMChannel | TeamChannel | PartialChannel | null;
    get author(): User | null;
    /**
     * Add a reaction to this message
     * @hidden
     */
    react(emoji: string): unknown;
    /**
     * Remove a reaction from this message
     * @hidden
     */
    unreact(emoji: string): unknown;
    /**
     * Delete this message
     */
    delete(): Promise<Message | string>;
    /**
     * Edit the content of this message
     * @hidden
     */
    edit(content: string): Promise<Message>;
}
/**
 * Object representing a message that doesn't have enough data to construct a regular message.
 */
export declare class PartialMessage extends Base<PartialMessageData> {
    /**
     * The channelID in which this message was sent. Will always be present, even if the channel isn't cached
     * @readonly
     */
    readonly channelID: string;
    /**
     * The ID of the team this channel belongs to
     * @readonly
     */
    readonly teamID: string;
    /**
     * The plain text content that this message has
     */
    content: string;
    /**
     * The parsed but unjoined content that this message has
     */
    parsedContent: parsedMessage;
    /**
     * A boolean indicating that this is infact a partial message.
     * @readonly
     * @defaultValue true
     */
    readonly partial = true;
    constructor(client: Client, data: PartialMessageData);
    /**
     * Update the data in this structure
     * @internal
     */
    patch(data: APIMessage | Partial<APIMessage>): this;
    /**
     * Fetch a complete version of this message from the api, will error if the message has been deleted or isn't accessible by the client.
     */
    fetch(): Promise<Message>;
}
/**
 * Object representing information about a certain reaction emoji on a message. This is NOT an individual object of a specific reaction on a message.
 */
export declare class MessageReaction {
    client: Client;
    /**
     * The users that have reacted with the emoji this message reaction belongs to.
     * It will contain either fully fledged User objects if the users are cached before hand, or it will contain minimal data about the users.
     */
    readonly users: Collection<string, User | {
        id: string;
        webhookId?: string | null;
        botId?: string | null;
    }>;
    /**
     * Date the first user reacted with the emoji this message reaction belongs to
     */
    readonly createdAt: Date;
    /**
     * The ID of the emoji this message reaction belongs to.
     */
    readonly id: string;
    constructor(client: Client, data: APIMessageReaction);
}
//# sourceMappingURL=Message.d.ts.map