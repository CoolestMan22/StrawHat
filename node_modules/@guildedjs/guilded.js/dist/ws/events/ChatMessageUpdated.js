"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Message_1 = require("../../structures/Message");
const typings_1 = require("../../typings");
const Event_1 = __importDefault(require("./Event"));
class ChatMessageUpdatedEvent extends Event_1.default {
    constructor(client) {
        super(client);
    }
    ingest(data) {
        var _a, _b, _c, _d;
        if (data) {
            const channel = this.client.channels.cache.get(data.channelId);
            const oldMessage = (_a = channel === null || channel === void 0 ? void 0 : channel.messages) === null || _a === void 0 ? void 0 : _a.cache.get(data.message.id);
            if (!oldMessage && !((_c = (_b = this.client.options) === null || _b === void 0 ? void 0 : _b.partials) === null || _c === void 0 ? void 0 : _c.includes('MESSAGE'))) {
                return [false, 'Old message not cached!'];
            }
            const newMessage = (_d = oldMessage === null || oldMessage === void 0 ? void 0 : oldMessage._clone().patch(data.message)) !== null && _d !== void 0 ? _d : new Message_1.PartialMessage(this.client, Object.assign(Object.assign({}, data.message), { channelId: data.channelId }));
            this.client.emit(typings_1.events.MESSAGE_UPDATE, oldMessage, newMessage);
        }
        return [false, 'passthrough'];
    }
}
exports.default = ChatMessageUpdatedEvent;
//# sourceMappingURL=ChatMessageUpdated.js.map