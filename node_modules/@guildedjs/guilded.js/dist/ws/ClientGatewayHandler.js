"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientGatewayHandler = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const common_1 = require("@guildedjs/common");
const ws_1 = __importDefault(require("ws"));
const typings_1 = require("../typings");
const ChatMessageCreated_1 = __importDefault(require("./events/ChatMessageCreated"));
const ChatMessageReactionAdded_1 = __importDefault(require("./events/ChatMessageReactionAdded"));
const ChatMessageReactionDeleted_1 = __importDefault(require("./events/ChatMessageReactionDeleted"));
const ChatMessageUpdated_1 = __importDefault(require("./events/ChatMessageUpdated"));
const GatewayHandler_1 = __importDefault(require("./GatewayHandler"));
class ClientGatewayHandler extends GatewayHandler_1.default {
    constructor(client) {
        super(client);
        this.lastPing = null;
        this.reconnectionAmnt = 0;
        this.events = {
            chatMessageCreated: new ChatMessageCreated_1.default(this.client),
            chatMessageReactionAdded: new ChatMessageReactionAdded_1.default(this.client),
            chatMessageReactionDeleted: new ChatMessageReactionDeleted_1.default(this.client),
            chatMessageUpdated: new ChatMessageUpdated_1.default(this.client),
        };
    }
    init() {
        if (this.ws)
            return this;
        // eslint-disable-next-line max-len
        const socketURL = `wss://${common_1.ROUTES.BASE_DOMAIN}/socket.io/?jwt=undefined&guildedClientId=${this.client.rest.guildedMID}&EIO=3&transport=websocket`;
        this.ws = new ws_1.default(socketURL, {
            headers: {
                cookie: `hmac_signed_session=${this.client.rest.token};`,
            },
        });
        this.ws
            .on('open', () => (this.connectedAt = new Date()))
            .on('message', (incomingData) => {
            this.client.debug('Gateway message recieved', incomingData);
            this.dataRecieved(incomingData);
        })
            .on('close', (...closeData) => {
            var _a, _b, _c, _d, _e;
            this.client.debug(`Gateway connection terminated. Related data: ${closeData}`);
            const shouldntReconnect = ((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.ws) === null || _b === void 0 ? void 0 : _b.disallowReconnect) ||
                this.reconnectionAmnt >= ((_e = (_d = (_c = this.client.options) === null || _c === void 0 ? void 0 : _c.ws) === null || _d === void 0 ? void 0 : _d.reconnectLimit) !== null && _e !== void 0 ? _e : Infinity);
            this.client.destroy(!shouldntReconnect);
            if (shouldntReconnect)
                return this.client.emit('disconnected', closeData);
            this.reconnectionAmnt++;
            this.client.emit('reconnecting', closeData);
        });
        return this;
    }
    dataRecieved(incomingData) {
        var _a, _b, _c, _d;
        let data = incomingData;
        let opCode = '';
        for (const char of data) {
            if (!Number.isInteger(Number(char)))
                break;
            data = data.substring(1);
            opCode += char;
        }
        try {
            switch (Number(opCode)) {
                case 0: {
                    this.client.debug('Heartbeat started...');
                    let packet;
                    try {
                        packet = JSON.parse(data);
                    }
                    catch (e) {
                        throw new Error(`malformed payload! ${data}`);
                    }
                    this.sessionID = packet.sid;
                    this.heartbeater.start(packet.pingInterval);
                    break;
                }
                case 3: {
                    this.lastPing = Date.now();
                    this.ping = this.lastPing - this.heartbeater.lastPingSentAt;
                    this.client.debug('Ping returned. ');
                    break;
                }
                case 40: {
                    this.client.debug('Ready event recieved.');
                    this.client.emit(typings_1.events.READY);
                    break;
                }
                case 42: {
                    let EVENT_NAME, EVENT_DATA;
                    try {
                        [EVENT_NAME, EVENT_DATA] = JSON.parse(data);
                    }
                    catch (e) {
                        throw new Error(`malformed payload! ${data}`);
                    }
                    if ((_c = (_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.ws) === null || _b === void 0 ? void 0 : _b.disabledEvents) === null || _c === void 0 ? void 0 : _c.includes(EVENT_NAME))
                        return;
                    this.client.emit('raw', EVENT_NAME, EVENT_DATA);
                    let result;
                    switch (EVENT_NAME) {
                        case typings_1.websocket_events.CHAT_MESSAGE_CREATED: {
                            result = this.events.chatMessageCreated.ingest(EVENT_DATA);
                            break;
                        }
                        case typings_1.websocket_events.CHAT_MESSAGE_UPDATED: {
                            result = this.events.chatMessageUpdated.ingest(EVENT_DATA);
                            break;
                        }
                        case typings_1.websocket_events.CHAT_MESSAGE_REACTION_ADDED: {
                            result = this.events.chatMessageReactionAdded.ingest(EVENT_DATA);
                            break;
                        }
                        case typings_1.websocket_events.CHAT_MESSAGE_REACTION_DELETED: {
                            result = this.events.chatMessageReactionDeleted.ingest(EVENT_DATA);
                            break;
                        }
                    }
                    if (!(result === null || result === void 0 ? void 0 : result[0])) {
                        this.client.debug(`Event ${EVENT_NAME} dropped because of ${(_d = result === null || result === void 0 ? void 0 : result[1]) !== null && _d !== void 0 ? _d : 'unknown reason or not handled'}`);
                    }
                    break;
                }
            }
        }
        catch (e) {
            this.client.debug('Error parsing WS event', e);
        }
    }
}
exports.ClientGatewayHandler = ClientGatewayHandler;
//# sourceMappingURL=ClientGatewayHandler.js.map