"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamChannel = exports.DMChannel = exports.PartialChannel = void 0;
const collection_1 = __importDefault(require("@discordjs/collection"));
const util_1 = require("../util");
const Base_1 = require("./Base");
const MessageManager_1 = require("./managers/MessageManager");
const Role_1 = require("./Role");
/**
 * A partial channel, not enough data received however to construct a full channel type object.
 */
class PartialChannel extends Base_1.Base {
    constructor(client, data, _team, patch = true) {
        var _a, _b;
        super(client, data);
        this._team = _team;
        this.teamID = (_b = (_a = _team === null || _team === void 0 ? void 0 : _team.id) !== null && _a !== void 0 ? _a : ('teamId' in data && data.teamId ? data.teamId : null)) !== null && _b !== void 0 ? _b : null;
        this.messages = new MessageManager_1.MessageManager(this.client, this);
        this.createdAt = new Date(data.createdAt);
        this.createdBy = data.createdBy;
        this.type = data.type;
        this.contentType = data.contentType;
        if (patch)
            this.patch(data);
    }
    /**
     * Getter for retrieving the team this channel belongs to if it is cached.
     */
    get team() {
        return (0, util_1.retrieveTeamFromStructureCache)({
            _team: this._team,
            client: this.client,
            teamID: this.teamID,
        });
    }
    /**
     * Update the data in this structure.
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    patch(data) {
        return this;
    }
    /**
     * Send a message to this channel.
     * @param content Either a string content or RichEmbed to send to this channel.
     * @param embed A RichEmbed to send to this channel.
     */
    send(content, embed) {
        if (this.contentType !== 'chat') {
            throw new TypeError('This channel cannot have messages sent to it. It is not a chat channel.');
        }
        return this.client.channels.sendMessage(this, content, embed);
    }
}
exports.PartialChannel = PartialChannel;
/**
 * A channel between the client user and an other user(s) in DMs.
 */
class DMChannel extends PartialChannel {
    constructor(client, data) {
        super(client, data, null, false);
        /**
         * The type of this channel.
         * @defaultValue "DM"
         * @readonly
         */
        this.type = 'DM';
        /**
         * The type of this dm channel (???)
         * @readonly
         */
        this.dmType = 'Default';
        this.contentType = data.contentType;
        this.createdByWebhookID = data.createdByWebhookId;
        this.ownerID = data.ownerId;
        this.updatedAt = null;
        this.name = null;
        this.archivedAt = null;
        this.autoArchiveAt = null;
        this.users = new collection_1.default();
        this.parentChannelID = null;
        this.deletedAt = null;
        this.voiceParticipants = [];
        this.messages = new MessageManager_1.MessageManager(this.client, this);
        this.patch(data);
    }
    patch(data) {
        var _a, _b, _c;
        if ('name' in data && data.name !== undefined)
            this.name = (_a = data.name) !== null && _a !== void 0 ? _a : null;
        if ('description' in data && data.description !== undefined)
            this.description = data.description;
        if ('users' in data && data.users !== undefined) {
            for (const user of data.users) {
                this.users.set(user.id, (_b = this.client.users.cache.get(user.id)) !== null && _b !== void 0 ? _b : user);
            }
        }
        if ('updatedAt' in data && data.updatedAt !== undefined) {
            this.updatedAt = data.updatedAt ? new Date(data.updatedAt) : null;
        }
        if ('archivedAt' in data && data.archivedAt !== undefined) {
            this.archivedAt = data.archivedAt ? new Date(data.archivedAt) : null;
        }
        if ('autoArchiveAt' in data && data.autoArchiveAt !== undefined) {
            this.autoArchiveAt = data.autoArchiveAt ? new Date(data.autoArchiveAt) : null;
        }
        if ('parentChannelId' in data && data.parentChannelId !== undefined) {
            this.parentChannelID = (_c = data.parentChannelId) !== null && _c !== void 0 ? _c : null;
        }
        if ('deletedAt' in data && data.deletedAt !== undefined) {
            this.deletedAt = data.deletedAt ? new Date(data.deletedAt) : null;
        }
        if ('voiceParticipants' in data && data.voiceParticipants !== undefined) {
            this.voiceParticipants = data.voiceParticipants;
        }
        return this;
    }
}
exports.DMChannel = DMChannel;
/**
 * A channel residing in a Team
 */
class TeamChannel extends PartialChannel {
    constructor(client, data, _team, _group) {
        var _a, _b;
        super(client, data, _team, false);
        this._group = _group;
        /**
         * The type of this channel.
         * @defaultValue "Team"
         * @readonly
         */
        this.type = 'Team';
        this.messages = data.contentType === 'chat' ? new MessageManager_1.MessageManager(this.client, this) : null;
        this.teamID = (_a = _team === null || _team === void 0 ? void 0 : _team.id) !== null && _a !== void 0 ? _a : data.teamId;
        this.updatedAt = null;
        this.archivedAt = null;
        this.autoArchiveAt = null;
        this.parentChannelID = null;
        this.deletedAt = null;
        this.archivedByID = null;
        this.description = null;
        this.createdByWebhookID = (_b = data.createdByWebhookId) !== null && _b !== void 0 ? _b : null;
        this.channelCategoryID = null;
        this.addedAt = null;
        this.roleSynced = null;
        this.roles = new collection_1.default();
        this.tournamentRoles = new collection_1.default();
        this.userPermissions = [];
        this.tournamentRoleIDs = [];
        this.roleIDs = [];
        this.patch(data);
    }
    /**
     * The group object this channel belongs to, if cached.
     */
    get group() {
        var _a, _b, _c;
        return (_c = (_a = this._group) !== null && _a !== void 0 ? _a : (_b = this.team) === null || _b === void 0 ? void 0 : _b.groups.cache.get(this.groupID.toString())) !== null && _c !== void 0 ? _c : null;
    }
    patch(data) {
        var _a, _b, _c, _d;
        if ('name' in data && data.name !== undefined)
            this.name = (_a = data.name) !== null && _a !== void 0 ? _a : null;
        if ('description' in data && data.description !== undefined)
            this.description = data.description;
        if ('updatedAt' in data && data.updatedAt !== undefined) {
            this.updatedAt = data.updatedAt ? new Date(data.updatedAt) : null;
        }
        if ('archivedAt' in data && data.archivedAt !== undefined) {
            this.archivedAt = data.archivedAt ? new Date(data.archivedAt) : null;
        }
        if ('autoArchiveAt' in data && data.autoArchiveAt !== undefined) {
            this.autoArchiveAt = data.autoArchiveAt ? new Date(data.autoArchiveAt) : null;
        }
        if ('isPublic' in data && data.isPublic !== undefined)
            this.public = data.isPublic;
        if ('priority' in data && data.priority !== undefined)
            this.priority = data.priority;
        if ('groupId' in data && data.groupId !== undefined)
            this.groupID = data.groupId.toString();
        if ('parentChannelId' in data && data.parentChannelId !== undefined) {
            this.parentChannelID = data.parentChannelId;
        }
        if ('archivedBy' in data && data.archivedBy !== undefined)
            this.archivedByID = data.archivedBy;
        if ('archivedByWebhookId' in data && data.archivedByWebhookId !== undefined) {
            this.archivedByWebhookID = data.archivedByWebhookId;
        }
        if ('channelCategoryId' in data && data.channelCategoryId !== undefined) {
            this.channelCategoryID = data.channelCategoryId;
        }
        if ('deletedAt' in data && data.deletedAt !== undefined) {
            this.deletedAt = data.deletedAt ? new Date(data.deletedAt) : null;
        }
        if ('addedAt' in data && data.addedAt !== undefined) {
            this.addedAt = data.addedAt ? new Date(data.addedAt) : null;
        }
        if ('isRoleSynced' in data && data.isRoleSynced !== undefined)
            this.roleSynced = data.isRoleSynced;
        if ('rolesById' in data && data.rolesById !== undefined) {
            for (const role in data.rolesById) {
                const ROLE_DATA = data.rolesById[role];
                this.roles.set(role, new Role_1.RolePermissionOverwrite(this.client, ROLE_DATA, this));
            }
        }
        if ('userPermissions' in data && data.userPermissions !== undefined) {
            this.userPermissions = (_b = data.userPermissions) !== null && _b !== void 0 ? _b : [];
        }
        if ('roles' in data && data.roles !== undefined)
            this.roleIDs = (_c = data.roles) !== null && _c !== void 0 ? _c : [];
        if ('tournamentRoles' in data && data.tournamentRoles !== undefined) {
            this.tournamentRoleIDs = (_d = data.tournamentRoles) !== null && _d !== void 0 ? _d : [];
        }
        if ('tournamentRolesById' in data && data.tournamentRolesById !== undefined) {
            for (const role in data.tournamentRolesById) {
                const ROLE_DATA = data.tournamentRolesById[role];
                // this.tournamentRoles.set(role, new RolePermissionOverwrite(this.client, ROLE_DATA, this));
            }
        }
        return this;
    }
}
exports.TeamChannel = TeamChannel;
//# sourceMappingURL=Channel.js.map