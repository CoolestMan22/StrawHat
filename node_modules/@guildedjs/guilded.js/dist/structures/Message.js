"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageReaction = exports.PartialMessage = exports.Message = void 0;
const collection_1 = __importDefault(require("@discordjs/collection"));
const common_1 = require("@guildedjs/common");
const util_1 = require("../util");
const Base_1 = require("./Base");
const Channel_1 = require("./Channel");
/**
 * Object representing a message sent on the Guilded API.
 * This class is used over a partial message when we have full data.
 */
class Message extends Base_1.Base {
    constructor(client, data, _channel) {
        var _a, _b;
        super(client, data);
        this._channel = _channel;
        /**
         * Whether this message has been deleted or not.
         */
        this.deleted = false;
        /**
         * Mentions contained in this message
         */
        this.mentions = {
            channels: new collection_1.default(),
            members: new collection_1.default(),
            raw: {
                channels: new Set(),
                roles: new Set(),
                users: new Set(),
            },
            roles: new collection_1.default(),
            users: new collection_1.default(),
        };
        /**
         * A boolean indicating that this message is NOT partial
         * @readonly
         * @defaultValue false
         */
        this.partial = false;
        this.authorID = data.createdBy;
        this.channelID = data.channelId;
        this.teamID = (_a = data.teamId) !== null && _a !== void 0 ? _a : null;
        this._team =
            this.channel instanceof Channel_1.TeamChannel
                ? (_b = this.channel.team) !== null && _b !== void 0 ? _b : null
                : (this.teamID && this.client.teams.cache.get(this.teamID)) || null;
        this.reactions = new collection_1.default();
        this.patch(data);
    }
    /**
     * Update the data in this structure
     * @internal
     */
    patch(data) {
        var _a;
        if ('content' in data && data.content !== undefined) {
            this.parsedContent = (0, common_1.parseMessage)(data.content);
            this.content = this.parsedContent.parsedText;
            for (const userMention of this.parsedContent.mentions.users) {
                this.mentions.raw.users.add(userMention);
                const user = this.client.users.cache.get(userMention);
                if (!user)
                    continue;
                this.mentions.users.set(user.id, user);
                const member = (_a = this.team) === null || _a === void 0 ? void 0 : _a.members.cache.get(user.id);
                if (!member)
                    continue;
                this.mentions.members.set(member.id, member);
            }
            for (const channelMention of this.parsedContent.mentions.channels) {
                this.mentions.raw.channels.add(channelMention);
                const channel = this.client.channels.cache.get(channelMention);
                if (!channel)
                    continue;
                this.mentions.channels.set(channel.id, channel);
            }
            if (this.team) {
                for (const roleMention of this.parsedContent.mentions.roles) {
                    this.mentions.raw.roles.add(roleMention);
                    const role = this.team.roles.cache.get(roleMention);
                    if (!role)
                        continue;
                    this.mentions.roles.set(role.id, role);
                }
            }
        }
        if ('reactions' in data && data.reactions !== undefined) {
            for (const reaction of data.reactions) {
                this.reactions.set(reaction.customReactionId.toString(), new MessageReaction(this.client, reaction));
            }
        }
        return this;
    }
    /**
     * Retrieve the team object that channel this message belongs to belongs to.
     */
    get team() {
        return (0, util_1.retrieveTeamFromStructureCache)({
            _team: this._team,
            client: this.client,
            teamID: this.teamID,
        });
    }
    /**
     * Retrieve the channel object that this message belongs to.
     */
    get channel() {
        return (0, util_1.retrieveChannelFromStructureCache)({
            _channel: this._channel,
            channelID: this.channelID,
            client: this.client,
        });
    }
    get author() {
        var _a;
        return (_a = this.client.users.cache.get(this.authorID)) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Add a reaction to this message
     * @hidden
     */
    react(emoji) {
        return this.channel.messages.react(this, this.channelID, emoji);
    }
    /**
     * Remove a reaction from this message
     * @hidden
     */
    unreact(emoji) {
        return this.channel.messages.unreact(this, this.channelID, emoji);
    }
    /**
     * Delete this message
     */
    delete() {
        return this.client.channels.deleteMessage(this.channelID, this);
    }
    /**
     * Edit the content of this message
     * @hidden
     */
    edit(content) {
        return this.channel.messages.edit(this, content);
    }
}
exports.Message = Message;
/**
 * Object representing a message that doesn't have enough data to construct a regular message.
 */
class PartialMessage extends Base_1.Base {
    constructor(client, data) {
        super(client, data);
        /**
         * A boolean indicating that this is infact a partial message.
         * @readonly
         * @defaultValue true
         */
        this.partial = true;
        this.channelID = data.channelId;
        this.patch(data);
    }
    /**
     * Update the data in this structure
     * @internal
     */
    patch(data) {
        if ('content' in data && data.content !== undefined) {
            this.parsedContent = (0, common_1.parseMessage)(data.content);
            this.content = this.parsedContent.parsedText;
        }
        return this;
    }
    /**
     * Fetch a complete version of this message from the api, will error if the message has been deleted or isn't accessible by the client.
     */
    fetch() {
        return this.client.channels.fetchMessage(this.channelID, this.id);
    }
}
exports.PartialMessage = PartialMessage;
/**
 * Object representing information about a certain reaction emoji on a message. This is NOT an individual object of a specific reaction on a message.
 */
class MessageReaction {
    constructor(client, data) {
        var _a;
        this.client = client;
        this.id = data.customReactionId.toString();
        this.createdAt = new Date(data.createdAt);
        this.users = new collection_1.default();
        for (const user of data.users) {
            this.users.set(user.id, (_a = this.client.users.cache.get(user.id)) !== null && _a !== void 0 ? _a : user);
        }
    }
}
exports.MessageReaction = MessageReaction;
//# sourceMappingURL=Message.js.map