"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientUser = exports.Client = void 0;
const common_1 = require("@guildedjs/common");
const rest_1 = require("@guildedjs/rest");
const events_1 = require("events");
const ClientGatewayHandler_1 = require("../ws/ClientGatewayHandler");
const Channel_1 = require("./Channel");
const ChannelManager_1 = require("./managers/ChannelManager");
const TeamManager_1 = require("./managers/TeamManager");
const UserManager_1 = require("./managers/UserManager");
const Team_1 = require("./Team");
const User_1 = require("./User");
/**
 * The main class used to interact with the Guilded API
 *
 * ```javascript
 * const { Client } = require("@guildedjs/guilded.js");
 * const client = new Client();
 *
 * client.login({
 *  email: "email",
 *  password: "password"
 * })
 * ```
 */
class Client extends events_1.EventEmitter {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        super();
        this.options = options;
        /**
         * Manager in charge of managing REST requests to the guilded API
         * @private
         */
        this.rest = new rest_1.RestManager({
            apiURL: (_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.rest) === null || _b === void 0 ? void 0 : _b.apiURL) !== null && _c !== void 0 ? _c : "www.guilded.gg/api",
        });
        /**
         * Manager in charge of managing REST requests related to the guilded CDN
         * @private
         */
        this.cdn = new rest_1.RestManager({
            apiURL: (_f = (_e = (_d = this.options) === null || _d === void 0 ? void 0 : _d.rest) === null || _e === void 0 ? void 0 : _e.cdnURL) !== null && _f !== void 0 ? _f : common_1.ROUTES.MEDIA_DOMAIN,
        });
        /**
         * The User belonging to this Client
         * @readonly
         */
        this.user = null;
        /**
         * Handler in charge of handling gateway events and keeping the ws connection alive
         * @private
         */
        this.gateway = null;
        /**
         * The teams that this client is in
         * @readonly
         */
        this.teams = new TeamManager_1.TeamManager(this);
        /**
         * The channels that this client can access
         * @readonly
         */
        this.channels = new ChannelManager_1.ChannelManager(this);
        /**
         * The users belonging to anything handled by this client
         * @readonly
         */
        this.users = new UserManager_1.UserManager(this);
    }
    /**
     * Login the client and establish a connection with the Guilded API
     * ```
     * <client>.login({
     *  "email": "email@domain.com",
     *  "password": "securepassword"
     * })
     * ```
     */
    login(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        return __awaiter(this, void 0, void 0, function* () {
            if (!options.email || !options.password)
                throw new Error('You must provide an email/password');
            const [loginData] = yield this.rest.make({
                body: {
                    email: options.email,
                    password: options.password,
                },
                method: 'POST',
                path: '/login',
            }, false);
            const cookieJar = loginData.headers.get('Set-Cookie');
            if (!cookieJar)
                throw new Error('Incorrect Email/Pasword');
            this.rest.setAuth(cookieJar);
            const FETCH_ME = yield this.rest.get('/me');
            this.debug('Initial ME data recieved');
            this.user = new ClientUser(this, FETCH_ME.user);
            if (!((_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.startupRestrictions) === null || _c === void 0 ? void 0 : _c.dropTeams)) {
                const teamChannelDataRequests = [];
                for (const TEAM_DATA of FETCH_ME.teams) {
                    const team = new Team_1.Team(this, TEAM_DATA);
                    if (!((_f = (_e = (_d = this.options) === null || _d === void 0 ? void 0 : _d.cache) === null || _e === void 0 ? void 0 : _e.startupRestrictions) === null || _f === void 0 ? void 0 : _f.dropChannels)) {
                        teamChannelDataRequests.push(team.fetchChannels());
                    }
                    this.teams.add(team);
                }
                yield Promise.all(teamChannelDataRequests);
                this.debug('Initial Team data recieved.');
            }
            if (!((_j = (_h = (_g = this.options) === null || _g === void 0 ? void 0 : _g.cache) === null || _h === void 0 ? void 0 : _h.startupRestrictions) === null || _j === void 0 ? void 0 : _j.dropDMs)) {
                const FETCH_DMS = yield this.rest.get(`/users/${this.user.id}/channels`);
                for (const DM_DATA of FETCH_DMS.channels) {
                    const dm = new Channel_1.DMChannel(this, DM_DATA);
                    this.channels.add(dm);
                }
                this.debug('Initial DM Channel data recieved.');
            }
            this.gateway = new ClientGatewayHandler_1.ClientGatewayHandler(this).init();
            return this;
        });
    }
    /**
     * Set the password of this client.
     * @param newPassword the new password to set the current password to.
     */
    setPassword(newPassword) {
        if (typeof newPassword !== 'string')
            throw new TypeError('Expecting a string password for password change.');
        return this.rest.post('/users/me/password', { newPassword }).then(() => void 0);
    }
    /**
     * Destroy the current connection to the API
     * @param intentionToReconnect Whether or not you want the client to reconnect immediately. Used internally for handling WS disconnects
     */
    destroy(intentionToReconnect = false) {
        var _a;
        if (intentionToReconnect) {
            return (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.destroy(true);
        }
        else {
            this.rest.post('/logout', {}).finally(() => {
                var _a;
                this.rest.destroy();
                (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.destroy(false);
            });
        }
        this.debug('Client destroyed!');
        this.emit('disconnected');
    }
    /**
     * Used to emit debug statements
     * @hidden
     */
    debug(str, ...args) {
        // eslint-disable-next-line no-void
        return void this.emit('debug', `[DEBUG]: ${str}`, args);
    }
}
exports.Client = Client;
/**
 * The user belonging to this client
 */
class ClientUser extends User_1.User {
    constructor(client, data) {
        var _a, _b, _c, _d;
        super(client, data);
        this.blockedUsers = (_a = data.blockedUsers) !== null && _a !== void 0 ? _a : [];
        this.socialLinks = (_b = data.socialLinks) !== null && _b !== void 0 ? _b : [];
        this.badges = (_c = data.badges) !== null && _c !== void 0 ? _c : [];
        this.userPresenceStatus = data.userPresenceStatus;
        this.devices = (_d = data.devices) !== null && _d !== void 0 ? _d : [];
        this.patch(data);
    }
    /**
     * Update the data in this structure
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    patch(data) {
        super.patch(data);
        return this;
    }
    setPresence(presence) {
        const newPresence = PRECENSES[presence];
        if (!newPresence) {
            throw new TypeError(`Incorrect status option. Expected online, idle, dnd, or invisible. Recieved ${presence}`);
        }
        return this.client.rest.post('/users/me/presence', { status: newPresence }).then(() => {
            this.userPresenceStatus = newPresence;
            return this;
        });
    }
    setUsername(newUsername) {
        if (typeof newUsername !== 'string')
            throw new TypeError('Expected a string for username change.');
        return this.client.rest.put(`/users/${this.id}/profilev2`, { name: newUsername }).then(() => this);
    }
}
exports.ClientUser = ClientUser;
const PRECENSES = {
    dnd: 3,
    idle: 2,
    invisible: 4,
    online: 1,
};
//# sourceMappingURL=Client.js.map