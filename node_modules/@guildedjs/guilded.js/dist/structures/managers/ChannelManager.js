"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelManager = void 0;
const common_1 = require("@guildedjs/common");
const Channel_1 = require("../Channel");
const Message_1 = require("../Message");
const BaseManager_1 = require("./BaseManager");
const MessageManager_1 = require("./MessageManager");
class ChannelManager extends BaseManager_1.BaseManager {
    constructor(client) {
        var _a, _b, _c;
        super(client, Channel_1.PartialChannel, { maxSize: (_c = (_b = (_a = client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheMaxSize) === null || _c === void 0 ? void 0 : _c.channelsCache });
    }
    static resolve(channel) {
        return channel instanceof Channel_1.PartialChannel ? channel.id : channel;
    }
    /**
     * Send a message to a channel, using either the object or channel ID.
     * @param channel The ID or channel object of the target channel to send this message to
     */
    sendMessage(channel, content, embed) {
        const channelID = ChannelManager.resolve(channel);
        const [messageID, formattedContent] = (0, common_1.generateMessage)(content, embed);
        return this.client.rest
            .post(`/channels/${channelID}/messages`, Object.assign(Object.assign({}, formattedContent), { messageId: messageID }))
            .then(x => 'id' in x
            ? new Message_1.Message(this.client, x, channel instanceof Channel_1.PartialChannel ? channel : this.client.channels.add({ id: channel }))
            : messageID);
    }
    /**
     * Fetch a message from a channel from the API
     * @param channel The ID or channel object of the taret channel to fetch the message from.
     * @param message The ID, message object, or partial message object of the message to fetch.
     * @param cache Whether to cache the fetched message or not.
     */
    fetchMessage(channel, message) {
        const channelID = ChannelManager.resolve(channel);
        const messageID = MessageManager_1.MessageManager.resolve(message);
        return this.client.rest
            .get(`/channels/${channelID}/chat?messageId=${messageID}`)
            .then(x => {
            let targetChannel = channel instanceof Channel_1.PartialChannel ? channel : this.client.channels.cache.get(channelID);
            if (!channel) {
                targetChannel = new Channel_1.PartialChannel(this.client, { id: x.channelId }, null);
                this.client.channels.add(targetChannel);
            }
            const newMessage = new Message_1.Message(this.client, x, targetChannel);
            targetChannel.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /**
     * Delete a message from a channel.
     * @param channel The ID or channel object of the channel to delete the message from.
     * @param msg The ID or message object of the message to delete.
     */
    deleteMessage(channel, msg) {
        if (!msg)
            throw new TypeError('Expected a string or message object for message deletion.');
        const channelID = ChannelManager.resolve(channel);
        const messageID = MessageManager_1.MessageManager.resolve(msg);
        return this.client.rest.delete(`/channels/${channelID}/messages/${messageID}`).then(() => {
            var _a;
            const existingChannel = this.cache.get(channelID);
            const existingMessage = (_a = existingChannel === null || existingChannel === void 0 ? void 0 : existingChannel.messages) === null || _a === void 0 ? void 0 : _a.cache.get(messageID);
            if (existingMessage)
                existingMessage.deleted = true;
            return existingMessage !== null && existingMessage !== void 0 ? existingMessage : messageID;
        });
    }
    /**
     * Edit a message
     * @hidden
     */
    editMessage(channel, msg, newContent) {
        const channelID = ChannelManager.resolve(channel);
        const messageID = MessageManager_1.MessageManager.resolve(msg);
        return this.client.rest
            .put(`/channels/${channelID}/messages/${messageID}`, { content: (0, common_1.parseToMessage)(newContent) })
            .then(x => {
            const existingChannel = this.client.channels.cache.get(x.channelId);
            if (!existingChannel)
                return new Message_1.Message(this.client, x, null);
            const existingMessage = existingChannel.messages.cache.get(x.id);
            if (existingMessage)
                return existingMessage.patch(x);
            return existingChannel.messages.add(x);
        });
    }
}
exports.ChannelManager = ChannelManager;
//# sourceMappingURL=ChannelManager.js.map