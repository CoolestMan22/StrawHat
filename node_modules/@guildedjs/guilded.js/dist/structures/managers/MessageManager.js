"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageManager = void 0;
const collection_1 = __importDefault(require("@discordjs/collection"));
const Message_1 = require("../Message");
const BaseManager_1 = require("./BaseManager");
const ChannelManager_1 = require("./ChannelManager");
class MessageManager extends BaseManager_1.BaseManager {
    constructor(client, channel) {
        var _a, _b, _c;
        super(client, Message_1.Message, { maxSize: (_c = (_b = (_a = client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheMaxSize) === null || _c === void 0 ? void 0 : _c.messagesCache });
        this.channel = channel;
    }
    static resolve(message) {
        return message instanceof Message_1.Message || message instanceof Message_1.PartialMessage ? message.id : message;
    }
    /**
     * Edit a message
     */
    edit(msg, newContent) {
        return this.client.channels.editMessage(this.channel.id, msg, newContent);
    }
    /**
     * Delete a message
     */
    delete(msg) {
        return this.client.channels.deleteMessage(this.channel.id, msg);
    }
    /**
     * Add a reaction to this message
     */
    react(message, channel, emoji) {
        const messageID = MessageManager.resolve(message);
        const channelID = ChannelManager_1.ChannelManager.resolve(channel);
        return this.client.rest.post(`/channels/${channelID}/messages/${messageID}/reactions/${emoji}`, {});
    }
    /**
     * Remove a reaction from this message
     */
    unreact(message, channel, emoji) {
        const messageID = MessageManager.resolve(message);
        const channelID = ChannelManager_1.ChannelManager.resolve(channel);
        return this.client.rest.delete(`/channels/${channelID}/messages/${messageID}/reactions/${emoji}`, {});
    }
    /**
     * Fetch multiple messages from the channel this manager belongs to
     * @param amnt The amount of messages to fetch.
     * @param cache Whether to cache the fetched messages or not.
     */
    fetch(amnt, cache = true) {
        if (Number.isNaN(amnt))
            throw new TypeError('Expected a number for message fetching amount!');
        if (amnt > 100)
            amnt = 100;
        if (amnt < 0)
            amnt = 1;
        const messages = new collection_1.default();
        return this.client.rest
            .get(`/channels/${this.channel.id}/messages?limit=${amnt}`)
            .then(x => {
            for (const message of x.messages) {
                const tempMessage = this.add([this.client, message, this.channel]);
                messages.set(message.id, tempMessage);
                if (cache)
                    this.add(tempMessage);
            }
            return messages;
        });
    }
}
exports.MessageManager = MessageManager;
//# sourceMappingURL=MessageManager.js.map