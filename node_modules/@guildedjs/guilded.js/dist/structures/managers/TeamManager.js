"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamManager = void 0;
const Member_1 = require("../Member");
const Role_1 = require("../Role");
const Team_1 = require("../Team");
const BaseManager_1 = require("./BaseManager");
const TeamGroupManager_1 = require("./TeamGroupManager");
const TeamMemberManager_1 = require("./TeamMemberManager");
class TeamManager extends BaseManager_1.BaseManager {
    constructor(client) {
        var _a, _b, _c;
        super(client, Team_1.Team, { maxSize: (_c = (_b = (_a = client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheMaxSize) === null || _c === void 0 ? void 0 : _c.teamsCache });
    }
    static resolve(team) {
        return team instanceof Team_1.Team ? team.id : team;
    }
    /**
     * Add a role to a TeamMember
     * @param team The ID or team object of the Team the target member is in.
     * @param member The ID or member object of the Member that will have the role added to them.
     * @param role The ID or role object of the Role to add to the member.
     */
    addRoleToMember(team, member, role) {
        const roleID = role instanceof Role_1.Role ? role.id : role;
        const memberID = TeamMemberManager_1.TeamMemberManager.resolve(member);
        const teamID = TeamManager.resolve(team);
        return this.client.rest.put(`/teams/${teamID}/roles/${roleID}/users/${memberID}`).then(() => void 0);
    }
    /**
     * Remove a role from a TeamMember
     * @param team The ID or team object of the Team the target member is in.
     * @param member The ID or member object of the Member that will have the role removed from them.
     * @param role The ID or role object of the Role to remove from the member.
     */
    removeRoleFromMember(team, member, role) {
        const roleID = role instanceof Role_1.Role ? role.id : role;
        const memberID = TeamMemberManager_1.TeamMemberManager.resolve(member);
        const teamID = TeamManager.resolve(team);
        return this.client.rest.delete(`/teams/${teamID}/roles/${roleID}/users/${memberID}`).then(() => void 0);
    }
    /**
     * Kick a TeamMember
     * @param team The ID or team object of the Team the target member is in.
     * @param member The ID or member object of the Member that will be kicked
     */
    kickMember(team, member) {
        const memberID = TeamMemberManager_1.TeamMemberManager.resolve(member);
        const teamID = TeamManager.resolve(team);
        return this.client.rest.delete(`/teams/${teamID}/members/${memberID}`).then(() => void 0);
    }
    /**
     * Set a TeamMember's name
     * @param team The ID or team object of the Team the target member is in.
     * @param member The ID or member object of the Member that will be renamed.
     * @param newNickname The new nickname to give to the Member.
     */
    setMemberNickname(team, member, newNickname) {
        if (typeof newNickname !== 'string')
            throw new TypeError('Nickname must be a string!');
        const memberID = TeamMemberManager_1.TeamMemberManager.resolve(member);
        const teamID = TeamManager.resolve(team);
        return this.client.rest
            .put(`/teams/${teamID}/members/${memberID}/nickname`, { nickname: newNickname })
            .then(() => void 0);
    }
    /**
     * Creates an Invite for the Team
     * @param team The ID or team object of the Team.
     * @returns The ID of the created Invite
     */
    createInvite(team) {
        const teamID = TeamManager.resolve(team);
        return this.client.rest.post(`/teams/${teamID}/invites`, { teamId: teamID }).then(x => x.invite);
    }
    deleteInvite(team, inviteID) {
        if (typeof inviteID !== 'string')
            throw new TypeError('InviteID must be a string!');
        const teamID = TeamManager.resolve(team);
        return this.client.rest.delete(`/teams/${teamID}/invites/${inviteID}`).then(x => x.id);
    }
    /**
     * Creates a Teamchannel
     * @param team
     * @param group
     * @param name
     * @param contentType
     * @param channelCategoryId
     * @param isPublic
     * @returns
     */
    createChannel(team, group, name, contentType, channelCategoryId = null, isPublic = false) {
        if (typeof name !== 'string') {
            throw new TypeError('Name must be a string!');
        }
        const teamID = TeamManager.resolve(team);
        const groupID = TeamGroupManager_1.TeamGroupManager.resolve(group);
        return this.client.rest.post(`/teams/${teamID}/groups/${groupID}`, {
            channelCategoryId,
            contentType,
            isPublic,
            name,
        });
        // .then(x => new TeamChannel(this.client, x, null, null));
    }
    /**
     * Fetch a team, will retrieve from cache if exists
     * @param id the ID of the team to fetch.
     * @param cache Whether to cache the fetched Team or not.
     */
    fetch(id, cache = true) {
        return this.client.rest.get(`/teams/${id}`).then(data => {
            const cachedTeam = this.client.teams.cache.get(id);
            if (cache && cachedTeam) {
                cachedTeam.patch(data.team);
                for (const member of data.team.members) {
                    const existingMember = cachedTeam.members.cache.get(member.id);
                    if (existingMember)
                        existingMember.patch(member);
                    else
                        cachedTeam.members.cache.set(member.id, new Member_1.Member(this.client, member, cachedTeam));
                }
            }
            return cachedTeam !== null && cachedTeam !== void 0 ? cachedTeam : new Team_1.Team(this.client, data.team);
        });
    }
}
exports.TeamManager = TeamManager;
//# sourceMappingURL=TeamManager.js.map