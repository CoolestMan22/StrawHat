"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Team = void 0;
const collection_1 = __importDefault(require("@discordjs/collection"));
const Base_1 = require("./Base");
const Channel_1 = require("./Channel");
const TeamGroupManager_1 = require("./managers/TeamGroupManager");
const TeamMemberManager_1 = require("./managers/TeamMemberManager");
const TeamRoleManager_1 = require("./managers/TeamRoleManager");
/**
 * A team is the basis of Guilded, it is where TeamChannels, TeamMembers, and TeamRoles reside.
 */
class Team extends Base_1.Base {
    constructor(client, data) {
        super(client, data);
        this.createdAt = new Date(data.createdAt);
        this.members = new TeamMemberManager_1.TeamMemberManager(this.client, this);
        this.groups = new TeamGroupManager_1.TeamGroupManager(this.client, this);
        this.roles = new TeamRoleManager_1.TeamRoleManager(this.client, this);
        this.discord = { guildID: null, name: null };
        this.banners = { large: null, medium: null, small: null };
        this.games = [];
        this.admin = null;
        this.banned = null;
        this.bio = null;
        this.invitable = null;
        this.measurements = {
            matchmakingGameRanks: [],
            mostRecentMemberLastOnline: 0,
            numFollowers: 0,
            numFollowersAndMembers: 0,
            numMembers: 0,
            numMembersAddedInLastDay: 0,
            numMembersAddedInLastMonth: 0,
            numMembersAddedInLastWeek: 0,
            numRecentMatchWins: 0,
            numRecentMatches: 0,
            subscriptionMonthsRemaining: null,
        };
        this.timezone = null;
        this.type = null;
        this.patch(data);
    }
    /**
     * Update the data in this structure
     * @internal
     */
    patch(data) {
        var _a, _b, _c;
        if ('isAdmin' in data && data.isAdmin !== undefined)
            this.admin = data.isAdmin;
        if ('baseGroup' in data && data.baseGroup !== undefined)
            this.baseGroupID = data.baseGroup.id;
        if ('isUserBannedFromTeam' in data && data.isUserBannedFromTeam !== undefined) {
            this.banned = data.isUserBannedFromTeam;
        }
        if ('bio' in data && data.bio !== undefined)
            this.bio = data.bio;
        if ('description' in data && data.description !== undefined)
            this.description = data.description;
        if ('isFavorite' in data && data.isFavorite !== undefined)
            this.favorited = data.isFavorite;
        if ('userFollowsTeam' in data && data.userFollowsTeam !== undefined)
            this.followed = data.userFollowsTeam;
        if ('canInviteMembers' in data && data.canInviteMembers !== undefined)
            this.invitable = data.canInviteMembers;
        if ('measurements' in data && data.measurements !== undefined)
            this.measurements = data.measurements;
        if ('memberCount' in data && data.memberCount !== undefined)
            this.memberCount = parseInt(data.memberCount);
        if ('name' in data && data.name !== undefined)
            this.name = data.name;
        if ('ownerId' in data && data.ownerId !== undefined)
            this.ownerID = data.ownerId;
        if ('isPro' in data && data.isPro !== undefined)
            this.pro = data.isPro;
        if ('isPublic' in data && data.isPublic !== undefined)
            this.public = data.isPublic;
        if ('isRecruiting' in data && data.isRecruiting !== undefined)
            this.recruiting = data.isRecruiting;
        if ('subdomain' in data && data.subdomain !== undefined)
            this.subdomain = data.subdomain;
        if ('timezone' in data && data.timezone !== undefined)
            this.timezone = data.timezone;
        if ('type' in data && data.type !== undefined)
            this.type = data.type;
        if ('isVerified' in data && data.isVerified !== undefined)
            this.verified = data.isVerified;
        if ('discordGuildId' in data && data.discordGuildId !== undefined)
            this.discord.guildID = data.discordGuildId;
        if ('discordServerName' in data && data.discordServerName !== undefined) {
            this.discord.name = data.discordServerName;
        }
        if ('games' in data && data.games)
            this.games = data.games;
        if ('homeBannerImageLg' in data && data.homeBannerImageLg !== undefined) {
            this.banners.large = data.homeBannerImageLg;
        }
        if ('homeBannerImageMd' in data && data.homeBannerImageMd !== undefined) {
            this.banners.medium = data.homeBannerImageMd;
        }
        if ('homeBannerImageSm' in data && data.homeBannerImageSm !== undefined) {
            this.banners.small = data.homeBannerImageSm;
        }
        if (!((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.disableMembers) && 'members' in data && ((_c = data.members) === null || _c === void 0 ? void 0 : _c.length)) {
            for (const member of data.members) {
                this.members.add(member);
            }
        }
        return this;
    }
    /**
     * Create an invite to this team
     */
    createInvite() {
        return this.client.teams.createInvite(this.id);
    }
    deleteInvite(inviteID) {
        return this.client.teams.deleteInvite(this.id, inviteID);
    }
    /**
     * Creates a Teamchannel and fires a CreateChannelEvent on success.
     * @hidden
     * @param name The name of the channel.
     * @param contentType The type of the channel.
     * @param channelCategoryID the category's ID to create this channel under.
     * @param isPublic whether or not this channel should be visible to users who aren't in the team.
     * @returns
     */
    createChannel(name, contentType, channelCategoryID = null, isPublic = false) {
        return this.client.teams.createChannel(this.id, this.baseGroupID, name, contentType, channelCategoryID, isPublic);
    }
    /**
     * Retrive the banner belonging to this server depending on size
     * @param size the size of the returned image url.
     */
    bannerURL(size = 'small') {
        let url;
        switch (size) {
            case 'small': {
                url = this.banners.small;
                break;
            }
            case 'medium': {
                url = this.banners.medium;
                break;
            }
            case 'large': {
                url = this.banners.large;
                break;
            }
            default: {
                throw new TypeError('bannerURL method only accepts small, medium, or large as the parameter');
            }
        }
        return url !== null && url !== void 0 ? url : null;
    }
    fetch() {
        return this.client.teams.fetch(this.id);
    }
    /**
     * Fetch all the channels belonging to this team
     */
    fetchChannels(cache = true) {
        const fetchedChannels = new collection_1.default();
        return this.client.rest.get(`/teams/${this.id}/channels`).then(x => {
            for (const channel of x.channels) {
                const group = this.groups.cache.get(channel.groupId.toString());
                const newChannel = new Channel_1.TeamChannel(this.client, channel, this, group !== null && group !== void 0 ? group : null);
                fetchedChannels.set(newChannel.id, newChannel);
                if (cache) {
                    switch (channel.contentType) {
                        case 'chat': {
                            group === null || group === void 0 ? void 0 : group.channels.add(newChannel);
                            this.client.channels.add(newChannel);
                            break;
                        }
                        case 'voice': {
                            // Add voice channel logic
                            break;
                        }
                    }
                }
            }
            return fetchedChannels;
        });
    }
}
exports.Team = Team;
//# sourceMappingURL=Team.js.map